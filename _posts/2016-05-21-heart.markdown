---
layout: post
title:  "Tutorial: Heart application"
date:   2016-05-21 13:00:00
images: images/heart1.jpg
excerpt:
    How to create the first Jive application
categories: tutorial SVG animation
---

Throughout this tutorial, we'll walk you through the creation of a basic Jive application with a bit of animation.

Here is the video demonstration how our app will work.

{% youtube VvJks6XVjNc %}

Download the source code from [jive-examples github repository](https://github.com/jiveui/jive-examples). And go to the heart directory.

The app can be run using the command line below.

{% highlight bash %}
haxelib run jive test [platform]
{% endhighlight %}

If it's not enough let's go together deeper.

#### Project structure

A Jive project is an [OpenFL](http://openfl.org) and [Haxe](http://haxe.org) project. So it must have a main class and project.xml as a project file.

- [OpenFl project description](http://www.openfl.org/documentation/getting-started/your-first-project/);
- [project.xml documentation](http://www.openfl.org/documentation/projects/project-files/xml-format/).

To enable Jive library for the project we need a line below in *project.xml*

{% highlight xml %}
<haxelib name="jive"/>
{% endhighlight %}

#### Start point

First of all our application needs a start point. It's the Application class.

{% highlight java linenos %}
package ;

import view.MainWindow;
import viewmodel.MainViewModel;
import jive.*;

class Application {
    public function new() {
        Jive.start();
        var w: MainWindow = new MainWindow();
        w.dataContext = new MainViewModel();
        w.opened = true;
    }
}
{% endhighlight %}

The Application constructor only

- initializes Jive;
- creates and opens the main Jive window;
- creates the main view model.

Here we need to pause and have a bit of information about Model-View-ViewModel concept and how it works for Jive.

#### MVVM idea

Jive is based on:

the [Model - View - ViewModel idea](https://en.wikipedia.org/wiki/Model–view–viewmodel).

> MVVM facilitates a separation of development of the graphical user interface (a markup language or GUI code)
> from development of the business logic (the data model).
> The view model of MVVM is a value converter; meaning the view model is responsible for exposing (converting)
> the data objects from the model in such a way objects are easily managed and presented.
>
> In this respect, the view model is more model than view, and handles most if not all of the view's display logic.

and [the Data Binding](https://en.wikipedia.org/wiki/UI_data_binding). It's a way to implement a link between views and view models.

So for our app we need and it's enough:

- a main view; It contains all graphics and layout it.
- a main view model. It handle the whole behavior (animation).

#### View: Component

All views in Jive are [Components](/api/jive/Component.html). The important parts of Component's interface are below.

{% highlight java linenos %}
class Component {
    public var x: Metric;
    public var y: Metric;
    public var width: Metric;
    public var height: Metric;
    public var margin: MetricInsets;
    public var parent: Container;
}
{% endhighlight %}

#### View: Window

As a main view we use [Window](/api/jive/Window.html).

The window component is a root UI container for Jive application. We extend it to contain all our graphics.

{% highlight xml linenos %}
<?xml version="1.0" encoding="UTF-8"?>
<Window
        xmlns="jive"
        xmlns:geom="jive.geom"
        xmlns:haxe="http://haxe.org/"
        width="{Binding windowWidth}"
        height="{Binding windowHeight}">
    <haxe:Implements>
    <![CDATA[
        jive.DataContextControllable<viewmodel.MainViewModel
        >]]>
    </haxe:Implements>

    ...

</Window>
{% endhighlight %}


#### View: Svg

The graphics container in Jive is the Svg component:

{% highlight java linenos %}
class Svg extends Component {
    public var content: String;
}
{% endhighlight %}

The content property is the pure SVG content

#### Coordinates and sizes: absolute, virtual, percent

All coordinates and sizes of them have type **Metric**:

{% highlight java linenos %}
enum Metric {
    absolute(value: Int);
    virtual(value: Int);
    percent(value: Float);
    none;
}
{% endhighlight %}

- *absolute* means that value is a number of pixels.
- *virtual* means that value is a number of virtual pixels depending on the PPI of a display.
- *percent* means that the real value of the size will be calculated basing on the parent size.


#### ViewModel